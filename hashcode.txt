java中的hash码是通过传入类的属性值而计算出来的，而哈希码计算是一套固定的算法，这决定了如果输入是一致的，那么输出也是一致的，也就是说如果一个类的两个对象，它们的属性值都是一样的，那么这两个对象的hash码是一样的。

对于基于hash而实现的集合HashMap，它存储元素底层采用的是hash表，是数组+链表+红黑树的形式，数组中的每一项的位置也被及叫做桶，HashMap存储元素时会计算出元素的hash码，然后再通过哈希码计算出存储在数组中的索引位子，也就是桶的位子，然后将该元素存储到对于的桶中。计算位子的算法也是固定的，即hash码相同，那么计算出的索引位置也是相同的。

对于不同的元素，有可能计算出相同的hash码，这就导致可能有多个元素命中同一个索引位置在，它们会存储在同一个桶中，这种现象叫做hash冲突。我们都知道数组的每一个项只能存储一个元素，所以当一个元素进入hash表发现当前位置没有元素时，这个元素会存储在这个位置上，如果第二个元素发生了hash冲突，它也会来的此位置，但是第一个元素已经在这里了，那么第二个元素就会挂载到第一个元素的后面，如此下去，发生hash冲突的多个元素之间就会形成链表结构或红黑树结构(链表过长时转换)。

HashMap中存储的是键值对，但是参与计算hash码的是key，也就是说这个键值对存储在哪个桶是由key来决定的。
从HashMap中取出元素有这些情况：
1：通过给定的key计算出桶的位置，然后到这个位置上发现没有元素，也就是null，那么返回null，这种情况就是没有用存入该键值对。
2：通过给定的key计算出桶的位置，然后到这个位置上发现只有一个元素，那么直接返回该元素的value。
3：通过给定的key计算出桶的位置，然后到这个位置上发现有多个元素，那么遍历这些元素，调用equals()比较元素的key，如果找到了对应的key，那么返回该元素的value，如果遍历完都找不到，返回null

一般重写equals方法要求一起重写hashcode方法。
hashcode是Object类的方法，也就是生成hash码的方法，它在被重写前是与对象的地址值挂钩的，可以简单的理解为生成的hash码就是地址值。如果一个类没有重写hashcode，它的两个对象，即便它们的属性值完全一样，hashcode生成的hash码也是不一样的，因为两个对象的地址值不一样。
我们重写hashcode方法让它根据属性值来生成，那么两个对象的属性值只要是一样的，那么它们生成的哈希码就是一样的。

假设我们只重写了equals方法让它通过属性来比较，而没有重写hashcode方法，那么当我们用自定义对象作为key是就会出现一些问题，比如：
Person person1 = new Person("Alice", 25);
Person person2 = new Person("Alice", 25);
map.put(person1, "First");
map.get(person2)	// 返回null
我们定义了两个对象person1和person2，它们重写了equals，且属性值一样，那么它们两个对象是相等的，第一次我用person1作为key存储值，第二次我用person2取出值，因为它们是相等的，即key是相等的，那么因该取出"First"，但实际上取出的是null，因为它们没有重写hashcode，导致hash码是以对象的内存地址为准，即两个对象的hash码不一样，hash码不一样，造成存入和查找的桶的位置也不一样，这就是为什么返回了null
举个更加明了的例子，String也是一个对象，它重写了equals和hashcode，如果它没有重写hashcode，那么
map.put("k", "First");
map.get("k")	// 返回null
第二此取出来的是null。
或者还有更差的情况，第二个key命中了其他的桶，而这个桶只有一个元素，那么会直接返回这个元素，根本不是我们第一次存入的元素。
所以，重写hashcode是为了保证取出元素时让key发生hash冲突从而命中目标桶的位置，而不是命中其他桶，返回其他值或返回null。